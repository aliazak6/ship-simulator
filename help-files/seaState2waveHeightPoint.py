import numpy as np
def seaState2waveHeightPoint(beta, t, muVec, dmu, wVec, dw, e, x, y, S):
    # SEASTATE2WAVEHEIGHTPOINT Takes in sea state and plots a wave height. Uses the 
    # Bretschneider spectrum.
    #
    # Inputs:
    #   - seaState: integer in interval [1, 9].
    #   - beta:     direction of main wave in rad.
    #   - t:        double. point in time
    #   - muVec:    angle directions vector. E.g.: -pi/2:dmu:pi/2. If muVec=[],
    #               then the waves generated will be one-directional (long-
    #               crested).
    #   - dmu:      direction interval taken in muVec. Used if muVec ~= [].
    #   - wVec:     vector containing the frequencies
    #   - dw:       the difference between each frequency in wVec
    #   - e:        the random phases of the waves.
    #   - x:        the x coordinate
    #   - y:        the y coordinte
    #   - S:        The spectral density vector generated by the function
    #               "creteSpectrum"
    #
    # Ouput:
    #   - eta:      The wave height at point (x,y) at time t


    g = 9.81
    # Get the wave heights for all coordinates (x,y) for time t.
    # For each coordinate (x,y), sum the contribution of all the waves
    # to get the final wave amplitude at that point = sumOfWaves.
    sumOfWaves = 0
    for k in range(len(wVec)):
        w_k = wVec[k]
        
        if len(muVec) == 0:  # Long-crested
            coeff = w_k ** 2 / g
            e_k = e[k]
            amp = np.sqrt(2 * S[k] * dw)
            wave = amp * np.cos(coeff * (x * np.cos(-beta) + y * np.sin(-beta)) - w_k * t + e_k)
            sumOfWaves += wave
        else:  # Short-crested
            for i in range(len(muVec)):
                e_ik = e[i, k]
                mu_i = muVec[i]
                amp = np.sqrt(2 * S[k] * spread(mu_i) * dw * dmu)
                wave = amp * np.cos(w_k**2/g * (x * np.cos(mu_i - beta) + y * np.sin(mu_i - beta)) - w_k * t + e_ik)
                sumOfWaves += wave
    
    eta = sumOfWaves
    return eta

def spread(mu):
    if -np.pi/2 <= mu <= np.pi/2:
        return (2 / np.pi) * np.cos(mu)**2
    else:
        return 0
